import { newUnibeautify, Unibeautify, Beautifier, Language } from "unibeautify";
import beautifiers from "./beautifiers";
import { Disposable, CompositeDisposable } from "atom";
import Config from "./config";
import * as Promise from "bluebird";
import * as path from "path";
import * as _ from "lodash";
const pkg = require("../package");

declare const atom: any;
declare type IEditor = any;

export class AtomBeautify {
    private unibeautify: Unibeautify;
    private subscriptions: CompositeDisposable;

    public activate(state: any): void {
        console.log("activated!!");
        this.unibeautify = newUnibeautify();
        this.unibeautify.loadBeautifiers(beautifiers);
        this.subscriptions = new CompositeDisposable();
        this.subscriptions.add(this.handleSaveEvent());
        this.subscriptions.add(atom.commands.add("atom-workspace", "atom-beautify:beautify-editor", this.beautifyEditor.bind(this)));
        this.subscriptions.add(atom.commands.add("atom-workspace", "atom-beautify:help-debug-editor", this.debug.bind(this)));
        this.subscriptions.add(atom.commands.add("atom-workspace", "atom-beautify:open-settings", this.openSettings.bind(this)));
        this.subscriptions.add(atom.commands.add(".tree-view .file .name", "atom-beautify:beautify-file", this.beautifyFile.bind(this)));
        this.subscriptions.add(atom.commands.add(".tree-view .directory .name", "atom-beautify:beautify-directory", this.beautifyDirectory.bind(this)));
    }

    public deactivate(): void {
        return this.subscriptions.dispose();
    }

    public get config() {
        return _.merge(Config, require('./options.json'));
    }

    private handleSaveEvent(): CompositeDisposable {
      return atom.workspace.observeTextEditors((editor: IEditor) => {
        const disposable: CompositeDisposable = editor.getBuffer().onWillSave(({ path: filePath }: { path: string }) =>
          this.beautifyOnSaveHandler({filePath: filePath}, editor)
        );
        return this.subscriptions.add(disposable);
      });
    }

    private beautifyOnSaveHandler({ filePath }: { filePath: string }, editor: IEditor) {
      if(atom.config.get("atom-beautify.general.beautifyOnSave")) {
        if (editor.getPath() === undefined) {
          editor.getBuffer().setPath(filePath);
        }
        const grammarName = editor.getGrammar().name;
        const fileExtension = path.extname(filePath).substr(1);
        let text: string = null;
        if(!atom.config.get("atom-beautify.general.beautifyEntireFileOnSave") &&  !!editor.getSelectedText()) {
          text = editor.getSelectedText();
        }
        else {
          text = editor.getText();
        }
        //TODO Get beautify on save option for individual language from Atom settings
        const beautifyOnSave = true;
        console.log("Beautify file on save", {filePath, fileExtension, text, grammarName});
        if (beautifyOnSave) {
          return this.unibeautify.beautify({
            fileExtension,
            atomGrammar: grammarName,
            options: {},
            text: text
          }).then((result) => {
            editor.setText(result);
          }).catch(error => {
            this.showError(error);
          });
        }
      }
    }

    private beautifyEditor() {
      const editor: IEditor = atom.workspace.getActiveTextEditor();
      const grammarName = editor.getGrammar().name;
      let text: string = null;
      if (!!editor.getSelectedText()) {
        text = editor.getSelectedText();
      } else {
        text = editor.getText();
      }
      let fileExtension: string = null;
      if (editor.getPath()) {
        fileExtension = path.extname(editor.getPath()).substr(1);
      }
      return this.unibeautify.beautify({
        fileExtension,
        atomGrammar: grammarName,
        options: {},
        text: text,
      }).then((result) => {
        editor.setText(result);
      }).catch(error => {
        this.showError(error);
      });
    }

    private beautifyFile() {

    }

    private beautifyDirectory() {

    }

    private debug() {
      let debugInfo: string = "";
      const headers: { level: number; title: string; }[] = [];
      const tempToc: string = "<TABLEOFCONTENTS/>";
      const editor: IEditor = atom.workspace.getActiveTextEditor();

      addHeader(1, "Atom Beautify - Debugging information");
      debugInfo += `The following debugging information was generated by Atom Beautify on ${new Date()}. \
Please include this output into a Gist on GitHub and link to your issue. \
      \n\n---\n\n \
      ${tempToc} \
      \n\n---\n\n`;

      addHeader(2, 'System Info');
      addInfo('Platform', process.platform);
      addInfo('Atom Version', atom.appVersion);
      addInfo('Atom Beautify Version', pkg.version);

      addHeader(2, 'File Info');
      const filePath: string = editor.getPath();
      const grammarName: string = editor.getGrammar().name;
      const fileExtension: string = path.extname(editor.getPath()).substr(1);
      addInfo('Original File Path', filePath);
      addInfo('Original File Grammar', grammarName);
      addInfo('Original File Language', "");
      addInfo('Beautifiers Used', "");

      addHeader(2, 'Package Info');
      addInfo(null, `The raw package settings options\n \`\`\`json\n \
${JSON.stringify(atom.config.get('atom-beautify'), undefined, 4)}\n\`\`\``);

      addHeader(2, 'Before Beautification');
      const text = editor.getText();
      addInfo(null, `\`\`\`\n${text}\n\`\`\``);
      // let beautifiedText = this.unibeautify.beautify({
      //   fileExtension,
      //   atomGrammar: grammarName,
      //   options: {},
      //   text: text,
      // }).then((result) => {
      //
      // }).catch(error => {
      //
      // });

      let toc: string = "## Table Of Contents\n";
      headers.forEach(header => {
        const indent: string = "  ";
        const bullet: string = "-";
        const indentNum: number = header.level - 2;
        if (indentNum >= 0) {
          toc += (`${Array(indentNum+1).join(indent)}${bullet} [${header.title}](${linkifyTitle(header.title)})\n`);
        }
      });
      debugInfo = debugInfo.replace(tempToc, toc)

      atom.workspace.open()
      .then((editor: IEditor) => {
        editor.setText(debugInfo);
      }).catch((error: any) => {
        this.showError(error);
      });

      function addInfo(key: any, value: any) {
        if (key) {
          debugInfo += `**${key}**: ${value}\n\n`;
        } else {
          debugInfo += `${value}\n\n`;
        }
      }

      function addHeader(level: number, title: string) {
        debugInfo += `${Array(level+1).join('#')} ${title}\n\n`;
        headers.push({level, title});
      }

      function linkifyTitle(title: string) {
        title = title.toLowerCase();
        let p = title.split(/[\s,+#;,\/?:@&=+$]+/);
        const sep = "-";
        return p.join(sep);
      }

    }

    private openSettings() {
      atom.workspace.open('atom://config/packages/atom-beautify');
    }

    // ===== Helpers =====
    private getLoadedLanguages() {
      return this.unibeautify.getLoadedLanguages();
    }

    private getScrollTop(editor: any): any {
      const view = atom.views.getView(editor);
      return view && view.getScrollTop();
    }

    private setScrollTop(editor: any, value: any): void {
      const view = atom.views.getView(editor);
      view && view.setScrollTop(value);
    }

    private getCursors(editor: any) {
      const cursors: any[] = editor.getCursors();
      let posArray: any[] = [];
      for (let j = 0, len = cursors.length; j < len; j++) {
        const cursor: any = cursors[j];
        const bufferPosition: any = cursor.getBufferPosition();
        posArray.push([bufferPosition.row, bufferPosition.column]);
      }
      return posArray;
    };

    private setCursors(editor: any, posArray: any[]) {
      for (let i = 0, j = 0, len = posArray.length; j < len; i = ++j) {
        const bufferPosition = posArray[i];
        if (i === 0) {
          editor.setCursorBufferPosition(bufferPosition);
          continue;
        }
        editor.addCursorAtBufferPosition(bufferPosition);
      }
    };

    private showError(error: any, show: boolean = false) {
      if (show || !atom.config.get("atom-beautify.general.muteAllErrors")) {
        const stack: any = error.stack;
        const detail: string = error.description || error.message;
        return atom.notifications.addError(error.message, {
          stack: stack,
          detail: detail,
          dismissable: true
        });
      }
    };

};
